1. 数据结构/算法的
    （a）复杂度分析（b）来历 (c)是什么（d）为什么 (e) 应用场景

=========================================================

2. 10种常用，基本的数据结构 + 10种算法。

==========================================================

3. 复杂度分析
    （1）为什么要复杂度分析？来历？
       （a) 事后统计法依赖环境和数据规模。不需要数据，就可以粗略估计算法执行效率的方法。

     (2) 大O时间复杂度特点
        (a) 代码执行时间随数据规模增长的变化趋势。
        (b) 加法法则：T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
        (c) 乘法法则: T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))

     (3) 空间复杂度特点
         (a)算法的存储空间随数据规模增长的变化趋势。

     (4) 复杂度比较：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)

     (5) 最好时间复杂度
       （a）在最理想情况下的时间复杂度。

     (6) 最坏时间复杂度
        (a) 在最糟糕情况下的时间复杂度。

     (7) 平均时间复杂度
        (a) 期望值

     (8) 均摊时间复杂度

======================================================

4. 数组
    (1) 是什么 ？什么是数组？
         (a) 线性表 -- 只有前后两个方向。
         (b) 连续的内存空间和相同的数据类型 -- 根据下表随机访问。时间复杂度 O(1)。
         (c) 插入 - 怎么插入？ 在k位置插入，k~n 向后移动 平均时间复杂度 O(n)。怎么提高性能 ？在k位插入，将k位移动到n+1位置，时间复杂度O(1)。
         (d) 删除 - 平均时间复杂度O(n) 怎么提高性能？标记删除算法 mark-sweep。

    (2) 为什么？数组 vs 容器
         （a）优点：存储基本类型， 没有autoboxing, unboxing, 性能first。
          (b)缺点: 但需要手动扩容。

    (3) 使用场景： 性能优先-写框架，底层开发（jdk）

=========================================================

5. 链表
    (1) 是什么？
          (a) 线性表
          (b) 零散内存块(节点) + 指针（下一个节点地址）

    (2) 单链表
        (2.1) 是什么?
          (a) 后驱指针
          (b1) 删除节点的值=某个值 - 时间复杂度: O(n):先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
          (b2) 删除给定指针指向的节点 - 时间复杂度：O(n): 已经知道要删除的节点，但是无法获取前驱节点
          (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
          (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
          (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(n): 先找到前驱节点 O(n), 然后在节点插入O(1)
          (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

    (3) 循环单链表？
        (3.1) 是什么？
          (a) 尾结点指向链表头部的单链表
          (b1) 删除节点的值=某个值 - 时间复杂度: O(n):先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
          (b2) 删除给定指针指向的节点 - 时间复杂度：O(n): 已经知道要删除的节点，但是无法获取前驱节点
          (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
          (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
          (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(n): 先找到前驱节点 O(n), 然后在节点插入O(1)
          (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

        (3.2) 为什么？  链尾到链头很方便
        (3.3) 使用场景？处理数据具有环形结构时

    (4) 双向链表？-- 实际开发中经常使用
        (4.1) 是什么？
           (a) 前驱指针 + 后驱指针
           (b1) 删除节点的值=某个值 - 时间复杂度: O(n)，先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
           (b2) 删除给定指针指向的节点 - 时间复杂度：O(1), 已经知道要删除的节点，可以根据前驱指针获取前驱节点
           (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
           (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
           (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(1): 先找到前驱节点 O(1), 然后在节点插入O(1)
           (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

        (4.2) 为什么？在给定指针指向的情况下比单链表插入，删除的性能高
        (4.3) 使用场景？LinkedHashMap 使用了双向链表， 空间换时间

    (5) LRU缓存淘汰算法
        (a) 一个有序的单链表，表尾是越早之前访问的。
        (b) 一个新数据来了，链表中有的话删除，在把新数据放到表头;
        (c) 链表中没有的话，如果缓存满了，删除表尾节点，将新数据放入表头;如果缓存没满的话，将新数据放到表头。
        (d) 时间复杂度 O(n)
        (e)怎么优化，达到时间复杂度O(1) --- 散列表记录每个数据的位置。

    (6) 理解指针
        将某个变量赋值给指针，就是将这个变量的地址赋值给指针。也就是说，指针中存储的是这个变量的内存地址。

    (7) 注意边界条件下代码是否能正常工作
        (a) 链表为空时
        (b) 链表只有一个节点，只包含2个节点
        (c) 头结点，尾节点

================================================================





