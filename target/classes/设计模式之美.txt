1. 设计原理与思想
    1.1 面向对象 -- 以对象为基础，封装，抽象，继承，多态作为基石。
        1.1.1 封装
            (a) 是什么？对对象的访问权限的控制。
            (b) 为什么？
                (b1) 对对象的操作的安全性。
                (b2) 对对象操作的容易性。
        1.1.2 抽象
            (a) 是什么？
                (a1) 它是一个通用的设计思想。说小了，通过类的一个函数去包裹具体的实现逻辑就是一种抽象。
                     说大点，在架构设计中，一个领域/对象就是一种抽象。
                (a2) 不仅在面向对象编程中，也在其他编程范式中出现，有时候不看做是面向对象独有特性。
                (a3) 隐藏实现的复杂性，隔离实现的易变性，对外提供稳定的抽象接口。
            (b) 为什么？
                (b1) 面对复杂问题的时候，我们必须忽略掉一些非关键性的实现细节，只关注功能点。所以我们要抽象。e.g. 长转短/短转长。
        1.1.3 继承
            (a) 是什么？
                (a1) 事物与事物直接 is-a 的关系。
            (b) 为什么？
                (b1) 代码复用。
        1.1.4 多态
            (a) 是什么？
                (a1) 一个事物的多种形态。
                (a2) 子类替换父类。
                (a3) 继承 + 方法重写；接口类。
            (b) 为什么？
                (b1) 提高代码可复用性和可扩展性
        1.1.5 那些代码设计看起来是面向对象，其实是面向过程？
            (a) 滥用getter,setter方法
            (b) 滥用全局变量和全局方法
                (b1) Constant (b2) Utils (b3) 定义数据和方法分离的类(贫血模型) MVC。
        1.1.6 抽象类与接口
            (1) 两者不同点？
                (1a) 抽象类和接口的语法特性: 是否可以包含属性，具体方法。
                (1b) 两者实际意义: is-a ? has-a? 为了代码复用还是为了解耦实现和抽象？
                (1c) 抽象是自上向下（实现类->抽象类） 接口是自下向上(现有接口，再有实现)。
            (2) 应用场景？
                (2a) 就看是 is-a 还是has-a, 是为了代码复用还是解耦抽象。
        1.1.7 面向接口编程
            (1) 更确切的说是：基于抽象编程(理解时不要局限于java interface, 系统间的约定，可能是更上层的设计 rpc 接口 ，etc.)。 对外暴露稳定的抽象，对内封装不稳定的实现。不仅要满足当前的需求，更要能应对未来需求的变化。
                提高代码吗的扩展性。
            (2) 解决什么问题？ 解耦：上游系统面向接口编程，在实现变化的情况下，保证下游不改动代码。
            (3) 到底什么时候需要接口呢？看(2)
        1.1.8 继承 vs 组合
            (1) 为什么不推荐使用继承？如果继承层次过深入，会影响到代码的维护(如果修改父类方法，子类也要改变)
            (2) 怎么解决多继承带来的问题？接口+组合+委托。
            (3) 如何判断是用继承还是组合呢？根据具体情况，如果没有多层次继承，继承关系不复杂，是有继承。
        1.1.9 贫血模型 vs 充血模型
            (1) 贫血模型: 只包含数据，不包含业务逻辑的类; 数据和与操作分离的开来了，典型的面向过程编程的思想，叫做贫血模型。比如 MVC service 层。
            (2) 充血模型: 正好相反，数据+业务逻辑在同一个类中，是面向对象编程的风格。 DDD(领域驱动模型)。
            (3) 在充血模型下，什么样的功能逻辑应该放在service 层？
                (3a) service 与 repository 层的交流， 然后转换成领域模型。
                     这样是为了保持领域模型的独立性，不与其他层(repository),其他框架(spring) 耦合，让领域模型更加独立。
                (3b) service 层负责跨领域模型的业务聚合功能。
                (3c) service 负责一些非功能性的逻辑，比如:幂等，事务，记录日志，调用其他系统的RPC接口，发消息。
                (3d)
            (4) Controller 和 Repository 是否要要进行充血模型的建模？
                不需要。
        1.1.10 面向对象需求分析 -》 面向对象设计 -》 面向对象编程
            (1) 面向对象需求分析(w)
                (1a) 我们面向对象需求分析目的是什么？最终想获得什么？： 最终得到需求对应的功能点列表。
                (12) 我们该怎么做面向对象的需求分析?
                     从给出基础的解决方案开始，然后一步一步的迭代优化，最终得到得到需求对应的功能点列表，这样可以摆脱无从下手的窘境。
            (2) 面向对象设计
                (2a) 从梳理出的功能点出发，看看那些功能点职责相近，操作相同的属性，可否归并到一个类中。
                (2b) 识别功能点中的动词，作为候选的方法，把功能中涉及的名词，作为候选属性，然后在进行过滤。
                (2c) 定于类与类之间的交互：泛化，实现，组合，依赖。
                (2d) 将类组装起来并提供执行入口。e.g. 一组对外的API。

    1.2 设计原则
        1.2.1 单一责任原则(single responsibility principle)
            (1) 如何判断一个类的责任是否足够单一?
                (1a) 一个类只负责完成一个职责或者功能。
                (1b) 在不同的应用场景，不同阶段的需求背景下，对同一个类的责任是否单一的判断，可能不一样。

            (2) 为什么用这个原则?
                (2a) 最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性。

            (3) 类的职责是否设计得越单一越好?
                不是，拆分的过细，会降低代码的内聚性，影响可维护性。
        1.2.2 开闭原则(open closed principle)
            (1) 修改代码就意味着违背开闭原则吗？
                (1a) 添加一个新功能应该是，在已有代码基础上扩展代码(新增模块，类，方法), 而非修改已有代码(修改模块，类，方法)。
                (1b) 只要没有破坏原有代码的正常运行，没有破坏原有单元测试，我们就可以说，这是一个合格的修改代码。
            (2) 为什么用这个原则?
                (2a) 最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性。
        1.2.3 里氏替换原则(Liskov Substitution Principle)
            (1) 怎样的子类才是符合里氏替换原则？
                (1a) 子类的实现不能改变父类原有的约定（e.g. 异常抛出，输入，输出）
                (1b) 类似于集合，子类包含了父类。
            (2) 为什么用这个原则？
                (2a) 用来指导继承关系中子类该如何设计。
        1.2.4 接口隔离原则(Interface Segregation Principle)
            (1) 如何理解隔离原则？
                (1a) 服务端不应该 强迫或者不加限制的 暴露接口给客户端接口。
                (1b) 从多个api, 一个共有函数， java interface 不同颗粒度分析。
        1.2.5 依赖翻转原则(Dependency Inversion Principle)
            (1) 控制反转(Inversion Of Control)
                (1a) 控制指的控制什么？ 对程序执行流程的控制。
                (1b) 反转后是什么来控制？ 框架来控制对程序执行，不在是程序员。
                (1c) 控制反转是一种设计思想，用来指导框架的设计。
            (2) 依赖注入(DI)
                (2a) 什么是依赖注入？不通过new()在类的内部创建依赖的对象，而是在类的外部创建好了，然后注入到类中，比如通过构造函数，函数参数。
                (2b) 为什么要依赖注入? 提高可扩展性，可以灵活的替换依赖的类。
                (2c) 依赖注入是一种编程技巧。
            (3) 依赖注入框架
                (3a) 为什么要用框架来依赖注入？ 对象的创建和依赖的注入和业务无关，可以抽象出来由框架来自动完成。
            (4) 依赖反转原则
                (4a) 主要用来指导框架的设计。
                (4b) 高层次模块(调用者)不依赖底层模块(被调用者)，而是通过抽象来相互依赖。

        1.2.6 KISS
            (1) 目的：保持代码可读性和可维护性

        1.2.7 YAGNI(You Ain't Gonna It)
            (1) 不要过度设计
                * 提前引入大量常用依赖包
        1.2.8 DRY(Don't Repeat YourSelf)
            (1) 实现逻辑重复 -- 不违背DRY
            (2) 功能语义重复 -- 违背DRY
            (3) 代码执行重复 -- 违背DRY
            (4) 代码复用性(Code Reusability)
                (4a) * 不重复不代表可复用, 代码的"可复用性"是从代码开发者的角度讲的， "复用"是从代码使用者的角度来讲的。
                (4b) 提高代码的复用性
                     * 减少代码耦合
                     * 满足单一责任原则
                     * 业务和非业务逻辑分离
                     * 通用代码下沉
        1.2.9 迪米特法则（Law of Demeter - LOD）- 最小知识原则
            (1) 高内聚
                * 相近功能应该放在同一个类中， 不相近功能不应该放在同一个类中。
            (2) 松耦合
                * 类与类之间的依赖关系简单清晰。
            (3) 不该有直接依赖关系的类之间，不要有依赖; 有依赖关系的类之间，尽量只依赖必要的接口。

    1.3 规范和重构
        1.3.1 重构
            (1) 什么是重构
                * 在保持功能不变的前提下，利用设计思想，原则，模式 等等来优化代码。
            (2) 为什么要重构？(why)
                * 保证代码质量。
                * 对学到的设计原则，思想，模式的一种实践。
            (3) 到底重构什么? (what)
                (3a) 大重构
                    * 系统结构，模块,代码结构，类与类的关系的重构。
                (3b) 小重构
                    * 针对类，函数，变量的重构。
            (4) 什么时候重构?(when)
                (4a) 持续重构意识:主动，习惯，持续。
            (5) 该如何重构?(how)
                (5a) 大重构情况下
                    * 提前做好完善计划, 小步快跑，兼容老的逻辑。
                (5b) 小重构情况下
            (6) 怎么确保重构对逻辑不出错？- 单元测试
                (6a) 重构之后，新代码可以通过单元测试，说明代码逻辑性没有被破坏。
                (6b) 什么是单元测试？
                    * 测试对象是类或者函数，相对集成测试来说的(end-end,跨模块 业务场景测试)。
                (6c) 为什么要写单元测试？
                    * 发现代码的bug。
                    * 发现代码设计的问题- 很难编写单元测试，使用了大量静态函数，等等。
                    * 单元测试时执行持续重构的一个有效途径。
                (6d) 如何编写单元测试？
                    * 看测试用例是否覆盖所有可能性，corner case.
                (6e) 代码的可测试性？
                    * 编写单元测试的难易程度。
                    * 编写单元测试的有效手段 -- 依赖注入。
                    * Anit-Pattern
                        * 未决定的逻辑 - 抽到protect 方法， 在测试勒种复写。
                        * 滥用全局变量，静态方法
                        * 使用复杂的继承方法
                        * 高度耦合
            (7) 解耦
                (7a) 为什么要解耦？
                    * 人处理代码的能力是有限的，控制代码的复杂性。
                    * 提高代码的可读性和可维护性。
                (7b) 是否需要解耦?
                    * 主要看修改代码是否能做到开闭原则，是否会牵一发动全身。
                    * 类与类之间依赖复杂，混乱。
                (7c) 如何解耦？
                    * 封装和抽象 - 隐藏实现的复杂性，隔离实现的易变性，对外提供稳定的抽象接口。
                    * 中间层 -

        1.3.2 规范
            (1) 命名
                * 从代码阅读者的角度, 确认命名是否能够达意。
                * 借助对象这样一个上下文简化命名，函数参数名借助函数来简化命名。
            (2) 注释
                * 对于类来说，包含的信息比较多，一个简单的命名就不够详尽了，这时候通过注释"为什么", "做什么"，"怎么做"。
            (3) 把代码分割成更小的单元块。
            (4) 避免函数参数过多(>4)
                * 考虑函数责任是否单一。
                * 将参数封装成对象。
            (5) 不要用函数参数来控制逻辑 - 函数设计要责任单一
                * 不要在函数中使用布尔参数来控制内部逻辑。
                * 不要"根据参数合适否为null" 来控制逻辑。
            (6) 移除过深的嵌套层次。
            (7) 使用解释型变量。
                * 常亮取代魔法数字。
                * 使用解释型变量来解释复杂表达式。


=========================================================

2. 设计模式与范式
    2.1 创造型 (单工建原) - 对象的创建
        2.1.1 单例模式
            (a) 为什么使用单例？
                (*) 处理资源访问冲突
                (*) 表示全局唯一
            (b) 单例模式的问题
                (*) 违背了基于接口而非实现的原则，扩展性不好。
                (*) 不好测试。
            (c) 如何理解单例模式中的唯一性？
                (*) 单例模式的对象是在进程中唯一，在进程间不唯一。
            (d) 如何实现线程唯一的单例？
                (*) threadlocal/concurrenthashmap: key 是线程id, value 是对象。
                (*) e.g. Mybatis ErrorContext。
            (e) 如何实现集群环境(多进程)下的单例？
                (*) 需要将对象序列化并存储到外部共享存储区。
                (*) 一个进程获取存储对象后，需要给对象加锁，避免其他进程获取。
                (*) 进程使用完后，需要显式的删除对象，并且释放对象的锁。
            (f) 如何实现一个多例模式?
                (*) 同一个"类型"只能创建一个对象。不同类型可以创建多个对象，e.g. 枚举。

        2.1.2 工厂模式
            (a) 简单工厂，工厂模式，抽象工厂。
            (b) 什么场景下使用工厂模式？
                (*) 动态的根据不同的类型创建不同的对象。
                (*) 不需要根据不同类型创建不同对象，但是单个对象本身的创建过程太复杂，比如需要组合其他对象。
            (c) 依赖注入容器(IDC)
                (c1) 工厂模式和 IDC 的区别
                    (*) DIC 设计思想是基于工厂模式, 除了创建对象还有配置解析，对象生命周期管理的功能。

        2.1.3 建造者模式
            (a) 为什么有了工厂模式，构造函数，set方法，还需要使用使用建造者模式？
                (1) 建造者模式
                    (1.1) 解决的问题：创建一种类型的复杂对象，通过不同的方式（参数选择）去创建, 参数间还有一定的依赖和约束关系。
                    (1.2) 解决的问题：如果不校验参数间约束，通过set 方式创建的对象很可能不合法。
                * 工厂模式 解决的问题： 创建不同但是类型相关(继承，接口关系)的对象。

        2.1.4 原型模式
            (a) 如果创建对象成本比较大，我们通过对已有对象的复制的方式，创建新对象。
            (b) 什么叫创建对象成本比较大？
                (*) 比如复杂的计算，从RPC, 数据库，文件系统(IO) 中读取数据。
            (c) 浅拷贝和深拷贝
                (*) 浅拷贝：只会copy基本数据类型(int, long ..), 和引用对象的内存地址,不会copy对象本身。
                (*) 深拷贝: 完完全全的copy对象本身。
                (*) 深拷贝方式：(1) 递归对象直到基本数据类型。(2)将对象序列化，再反序列化成一个新对象。

    2.2 结构型 (代桥装适门组享) - 类或对象的组合
        2.2.1 代理模式
            (a) 思想：在不改变原始类(被代理类)的前提下，通过引入代理类来给原始类的方法附加功能。
            (b) 静态代理
                (*) 通过代理类和被代理类实现统一接口， 或者代理类继承被代理类。
            (c) 动态代理
                (c1) 为什么要动态代理？
                    (*) 原始类过多，代理类的数量会增加，不便于维护。
                    (*) 代理类需要将原始类中方法都重写一遍，违背了接口隔离原则。
                (c2) 代理的应用场景
                    (*) 业务系统非功能性需求，e.g. 监控，统计。
                    (*) RPC框架，框架代理了函数调用，把网络通信，数据编码解码封装起来了。
                    (*) 缓存中的应用：接口支持实时查询和缓存查询两种，根据请求的cached字段，AOP切面中完成缓存查询的功能。
            (d) 应用场景
                (d1) e.g. 动态代理: MyBatis Plugin

        2.2.2 桥接模式
            (a) 什么场景下使用桥接模式？
                (*) 当一个类的责任在多个独立(不同)的维度上存在多种变化的情况，我们将各个维度的变化单独拆分封装起来，
                    实现每个维度的各自独立扩展。然后根据类的责任在这些维度上的体现，将这些维度的变化组合(桥接)起来，实现这个类的责任。
            (b) 设计模式的思想：
                (*) 很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。

        2.2.3 装饰器模式
            (a) 什么场景下使用装饰器模式?
                (*) 附加和原始类相关的增强功能。
                (*) 解决继承关系过于复杂的问题。
                (*) e.g Spring TransactionAwareCacheDecorator
            (b) 设计模式思想：
                (*) 可以对原始类嵌套多个装饰器。
                (*) 对原始类增强功能
            (c) 装饰器 VS 代理
                (*) 意图不同: 代理类附加的是和原始类无关的功能，装饰类附加的是和原始类相似的增强功能。

        2.2.4 适配器模式
            (a) 什么场景使用?
                (a1) 统一多个外部系统的接口设计，提供和原始类不同的接口。
                (a2) 替换依赖的外部接口。
                (a3) e.g. Spring MVC HandlerAdapter
            (b) 设计思想
                (*) 补偿模式，解决接口不兼容的问题。

        2.2.5 门面模式
            (a) 什么场景使用?
                (*) 解决易用性:提供一组更简单，易用的接口
                (*) 解决性能问题: 通过一个门面接口替换多个接口调用，介绍网络通信成本。
                (*) 解决分布式事务问题。

        2.2.6 组合模式
            (a) 什么场景使用?
                (a1) 主要用于处理树形结构对象
                (a2) 组合模式主要应用在能表示成树形结构的一组数据上
                (a3) e.g. Spring CompositeCacheManager getCache(), getCacheNames()
            (b) 设计思想
                (*) 将一组对象(员工，部门)组织成树形结构, 已表示一种"部分-整体"的层次结构(部门与子部门的嵌套结构)。
                    组合模式让客户端可以统一单个对象(员工)和组合对象(部门)的处理逻辑(递归遍历)。
                (*) 对业务场景的一种数据结构和算法的抽象，数据可以表示成树的结构，业务需求可以通过递归遍历算法实现。

        2.2.7 享元模式
            (a) 设计思想
                (*) 共享不可变对象，对象复用，以减少内存消耗。
            (b) 使用场景
                (*) 在文本编辑中的应用: 文字格式享元。
                (*) 在棋牌游戏中的应用：棋子类型。
                (*) JAVA IntegerCache， LongCache(-127 ~ 128)
                    (*) Integer a = new Integer(123); - 不使用IntegerCache
                    (*) Integer a = 123; - 使用IntegerCache
                    (*) Integer a = Integer.valueOf(123) - 使用IntegerCache
                (*) 在JAVA String 里的使用
                    (*)String s1 = "小争哥";  -- 使用字符串常量池
                       String s3 = new String("小争哥"); -- 不使用字符串常量池
            (c) 享元vs 单例 vs 缓存 vs 对象池 -
                (*) 区分设计模式是从意图区分
                (*) 享元：共享对象，减少空间消耗。
                (*) 单例：强调只有一个对象，不允许多个对象的场景。
                (*) 缓存：提高访问效率，不是为了复用。
                (*) 对象池： 为了重复使用，节省对象创建花费的时间。

    2.3 行为型 (观模策责状迭访备解命中) - 类或对象之间的交互

        2.3.1 观察者模式
            (a) 设计思想
                (*) 解耦观察者和被观察者。
            (b) 使用场景
                (*) 注册成功后，发放优惠券改为发送邮件，并且发送一个站内信。
                (*) guava event-bus

        2.3.2 模板模式
            (a) 设计思想
                (*) 在一个方法中定义了算法(或者说是业务逻辑)的骨架，并且将某些步骤推迟到子类中去实现。
                (*) 复用:子类复用父类的模板方法。
                (*) 框架扩展:框架提供扩展点，让框架用户在不修改框架前提下，基于扩展点定制框架的功能。
            (b) 使用场景
                (*) Java Servlet doGet(), doPost()
                (*) JUnit TestCase setup(), teardown()
            (c) callback函数
                (*) 同步回调看起来像模板模式，异步回调看起来更像观察者模式。
                (*) 应用举例， JdbcTemplate.query(), setClickListener(), tomcat addShutdownHook()
            (d) 模板模式 VS 回调
                (*) 从应用场景来看，都是大的算法中替换某个步骤，起到代码复用和扩展的目的。
                (*) 从代码上上看，完全不同。

        2.3.3 策略模式
            (a) 原理和实现
                (*) 解耦策略的定义，创建，使用三部分。
                (*) 策略的定义 - 接口和实现类。
                (*) 策略的创建 - 策略工厂
                (*) 策略的使用 - 运行时动态决定使用哪种策略。
             (b) 使用场景
                (b1) 策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略.
                (b2) e.g. Spring AopProxy

        2.3.4 责任链模式
            (1) 为什么要用责任链模式？
                (*) 让代码符合开闭原则，提高扩展性。
            (2) 使用场景
                (*) 责任链模式过滤敏感词。
                (*) Servlet Filter。
                (*) Spring Interceptor。
                (*) MyBatis Plugin

        2.3.5 状态模式
            (1) 状态机实现方式 (state, event, action)
                (*) 分支逻辑法: 将每一种状态转移，直译成代码，大量if-elase, switch.
                (*) 查表法: 第一维表示当前状态，第二维表示事件，值表示当前状态经过事件后，转移到的新状态和执行的动作。
                    适合简单的action, 不适合复杂的逻辑（写库，发消息等等）
            (2) 设计思想
                (*) 状态模式是状态机的一种实现方式。
                (*) 将事件(event)触发的状态转移(transition)和动作执行(action)，拆分到不同的状态类中。
                (*) 状态类 和 状态机类 是双向依赖的关系。
            (3) 使用场景
                (*) 常在游戏，工作流引擎等系统中使用。


        2.3.6 迭代器模式
            (1) 为什么要用迭代器来遍历容器，为什么要给容器设计对应的迭代器？
                (*) 对于复杂的结构(比如树，图)有不同遍历方式，比如树有前序，中序遍历，按照层来遍历。有客户端实现这些遍历算法，增加了复杂度，
                    如果将这部分遍历的逻辑写到容器类中，也会导致容器代码的复杂。所以将遍历拆分到迭代器类中。
            (2) 迭代器模式接口定义三元素
                (*) hasNext() next(), currentItem()
            (3) 遍历集合的时候，为什么不能增删集合的元素？
                (*) 可能会导致某个元素遍历不到或者重复遍历。根据插入元素或者删除元素的位置和当前游标的位置决定。
            (4) 怎么解决改变集合对遍历产生的问题？
                (*) 让遍历报错，抛出异常。通过比较集合的成员变量modCount 和 迭代器成员变量expectedModCount 的值。

        2.3.7 访问者模式
            (1) 解决什么问题？
                (*) 将互相不依赖的一系列操作(visitor)和操作的对象解耦(visitable)。将visitor 定义在独立的类中。

        2.3.8 备忘录模式
            (1) 设计思想
                (a) 存储副本以便后期恢复
                (b) 不违背封装的前提下，实现上面(a)
            (2) 应用场景
                (*) 用来防止丢失，撤销，恢复等。
            (3) 对大对象的恢复，如何优化内存和时间消耗？
                (*) 低频全量，高频增量。

        2.3.9 命令模式
            (1) 设计思想
                (*) 最核心的实现手段，将函数封装成对象。
            (2) 主要作用和应用场景
                (*) 处理事件和命令---用来控制命令的执行，比如异步，延迟，排队执行命令，撤销重做命令，存储命令，给命令记录日志。

        2.3.10 解释器模式(Interpreter Design Pattern)
            (1) 设计思想
                (a) 规则， 表达式。 根据规则解释(interpreter)表达式(expression)。
                (b) 将规则解释表达式的工作拆分到各个小类中，以此来避免大而全的解释类。

            (2) 主要作用和应用场景
                (a) 编译器，规则引擎，正则表达式。
                (b) 自定义接口告警规则
                (c) e.g. SpEL，mybatis 动态SQL解析(sqlNode)

        2.3.11 中介模式(Mediator Design Pattern)
            (1) 设计思想
                (a) 网状关系 ---> 星型关系
                (b) 解耦参与者，封装参与者之间的交互。
            (2) 应用场景
                (a) 观察者模式 VS 中介模式
                    (*) 观察者：参与者之间是单向关系。
                    (*) 中介模式: 参与者之间是多向关系; 可能参与者执行的操作有一定的先后顺序。



==========================================================

3.

======================================================

4.

=========================================================

5.

================================================================

6.

================================================================




