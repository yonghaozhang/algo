1. 数据结构/算法的
    （a）复杂度分析（b）来历 (c)是什么（d）为什么 (e) 应用场景

=========================================================

2. 10种常用，基本的数据结构 + 10种算法。

==========================================================

3. 复杂度分析
    （1）为什么要复杂度分析？来历？
       （a) 事后统计法依赖环境和数据规模。不需要数据，就可以粗略估计算法执行效率的方法。

     (2) 大O时间复杂度特点
        (a) 代码执行时间随数据规模增长的变化趋势。
        (b) 加法法则：T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
        (c) 乘法法则: T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))

     (3) 空间复杂度特点
         (a)算法的存储空间随数据规模增长的变化趋势。

     (4) 复杂度比较：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)

     (5) 最好时间复杂度
       （a）在最理想情况下的时间复杂度。

     (6) 最坏时间复杂度
        (a) 在最糟糕情况下的时间复杂度。

     (7) 平均时间复杂度
        (a) 期望值

     (8) 均摊时间复杂度

======================================================

4. 数组
    (1) 是什么 ？什么是数组？
         (a) 线性表 -- 只有前后两个方向。
         (b) 连续的内存空间和相同的数据类型 -- 根据下表随机访问。时间复杂度 O(1)。
         (c) 插入 - 怎么插入？ 在k位置插入，k~n 向后移动 平均时间复杂度 O(n)。怎么提高性能 ？在k位插入，将k位移动到n+1位置，时间复杂度O(1)。
         (d) 删除 - 平均时间复杂度O(n) 怎么提高性能？标记删除算法 mark-sweep。

    (2) 为什么？数组 vs 容器
         （a）优点：存储基本类型， 没有autoboxing, unboxing, 性能first。
          (b)缺点: 但需要手动扩容。

    (3) 使用场景： 性能优先-写框架，底层开发（jdk）

=========================================================

5. 链表
    (1) 是什么？
          (a) 线性表
          (b) 零散内存块(节点) + 指针（下一个节点地址）

    (2) 单链表
        (2.1) 是什么?
          (a) 后驱指针
          (b1) 删除节点的值=某个值 - 时间复杂度: O(n):先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
          (b2) 删除给定指针指向的节点 - 时间复杂度：O(n): 已经知道要删除的节点，但是无法获取前驱节点
          (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
          (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
          (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(n): 先找到前驱节点 O(n), 然后在节点插入O(1)
          (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

    (3) 循环单链表？
        (3.1) 是什么？
          (a) 尾结点指向链表头部的单链表
          (b1) 删除节点的值=某个值 - 时间复杂度: O(n):先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
          (b2) 删除给定指针指向的节点 - 时间复杂度：O(n): 已经知道要删除的节点，但是无法获取前驱节点
          (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
          (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
          (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(n): 先找到前驱节点 O(n), 然后在节点插入O(1)
          (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

        (3.2) 为什么？  链尾到链头很方便
        (3.3) 使用场景？处理数据具有环形结构时

    (4) 双向链表？-- 实际开发中经常使用
        (4.1) 是什么？
           (a) 前驱指针 + 后驱指针
           (b1) 删除节点的值=某个值 - 时间复杂度: O(n)，先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
           (b2) 删除给定指针指向的节点 - 时间复杂度：O(1), 已经知道要删除的节点，可以根据前驱指针获取前驱节点
           (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
           (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
           (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(1): 先找到前驱节点 O(1), 然后在节点插入O(1)
           (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

        (4.2) 为什么？在给定指针指向的情况下比单链表插入，删除的性能高
        (4.3) 使用场景？LinkedHashMap 使用了双向链表， 空间换时间

    (5) LRU缓存淘汰算法
        (a) 一个有序的单链表，表尾是越早之前访问的。
        (b) 一个新数据来了，链表中有的话删除，在把新数据放到表头;
        (c) 链表中没有的话，如果缓存满了，删除表尾节点，将新数据放入表头;如果缓存没满的话，将新数据放到表头。
        (d) 时间复杂度 O(n)
        (e)怎么优化，达到时间复杂度O(1) --- 散列表记录每个数据的位置。

    (6) 理解指针
        将某个变量赋值给指针，就是将这个变量的地址赋值给指针。也就是说，指针中存储的是这个变量的内存地址。

    (7) 注意边界条件下代码是否能正常工作
        (a) 链表为空时
        (b) 链表只有一个节点，只包含2个节点
        (c) 头结点，尾节点

================================================================

6. 栈
   (1) 是什么？
        (a) 后进先出，先进后出。
        (b) 一种"操作受限"的线性表，只能在一端插入和删除。两种操作 push+pop。为什么要用这种受限的数据结构？特定的数据结构是对特定场景的抽象。
        (c) 支持动态扩容的顺序栈：学习摊还法分析时间复杂度。入栈 O(1), 出栈O(1)。

   (2) 为什么?
        (a) 为什么要用这种受限的数据结构？特定的数据结构是对特定场景的抽象。


   (3)使用场景
      当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特性。这时我们应该选择栈。
      (a) 栈在函数调用中（函数调用栈）

      (b) 表达式求值

      (c) 括号匹配

      (d) 浏览器前进后退功能

================================================================

7. 队列
    (1) 是什么?
        (a) 先进先出。
        (b) 一种"操作受限"的线性表. 两种操作：enqueue , dequeue。

    (2) 顺序队列
        (2.1) 是什么？
            (a) 基于数组结构，所以队列大小受限，如果不动态扩容的话。
            (b) 一个头指针，一个尾指针。 入队列时，尾指针后移动。出站头指针后移。
            (c) 如果队列已满（head=tail）就不插入;如果尾指针到尾部，但是头指针不在头部，将数据整体迁移。
            (d) 入队列，出队列时间复杂度O(n)。
        (2.2) 为什么？
            (a) 利用数组的有界性。
        (2.3) 使用场景
            (a) 响应时间敏感的系统，不让等待时间过长。 e.g. RPC

    (3) 链式队列
        (3.1) 是什么？
            (a) 基于链表结构，所以队列大小不受限。
            (b) 一个头指针指向头结点，一个尾指针指向尾节点。新入队列的元素发在尾部，从头部出队列。
            (c)入队列，出队时间复杂度都为O(n)。
        (3.2) 为什么？
            (a) 利用链表的无界性。
        (3.3) 使用场景
            (a) 响应时间不敏感的场景，比如离线job请求， 批量推送app push使用MQ 消峰。

    (4) 循环队列
        (4.1) 为什么用循环队列？
            (a) 用数组的时候，当tail==n, 会有数据搬移，影响性能。为了避免数据搬移。
        (4.2) 是什么？
            (a) 首尾相连，浪费一个位置没用。
            (b) 队满满条件： (tail + 1) % n = head。
            (c) 队列空条件：tail == head。
            (d) 入队列，出队时间复杂度都为O(n)。

     (5) 阻塞队列
        (5.1) 是什么？
            (a) 普通队列 + 阻塞功能
            (b) 满了不然插入，等待。
            (c) 空了不让取， 等待。
         (5.2) 为什么？
            (a)
         (5.3) 使用场景
            (a) 生产者-消费者模型

     (6) 并发队列
        (5.1) 为什么？
            (a) 如何在多线程操作同一个队列时，保证线程安全？
        (5.2) 是什么？
            (a) 简单方式： 在enqueue + dequeue 加上锁， 缺点：锁的颗粒度大，并发低。
            (b) 升级方式：CAS原子操作 -- 基于数组的循环队列。

     (7) 使用场景
        (7.1) 线程池中没有空闲线程，新的线程请求资源，线程池该怎么处理？
            (a) 非阻塞策略：拒绝请求
            (b) 阻塞策略：进入等待队列，等有空余线程后，取出请求继续处理。
            (c) 队列如何存储请求呢？
                (c1) 有界队列
                (c2) 无界队列
        (7.2) 资源有限场景下，当没有空闲资源的时候。


================================================================

8. 排序
    8.1
       (8.1.1) 如何分析一个排序算法？
          (a) 排序算法的执行效率
              (a1)最好，最坏，平均时间复杂度
              (a2)时间复杂度的系数，常数，低阶
              (a3)比较次数和交换（移动）次数
          (b) 是否原地排序 (空间复杂度 O(1))
          (c) 排序算法的稳定性 (稳定排序) : 待排序元素数组中，经过排序后，相同元素的顺序不变。

    8.2 O(n^2)
          (8.2.1) 冒泡排序
            (1) 是什么？
                (a) 比较相邻元素，看是否满足大小关系，不满足则互换。
                (b) 原地排序，稳定排序。
                (d) 最好时间复杂度O(n), 最坏时间复杂度O(n^2),平均时间复杂度O()。
                (e) 最差情况有序度是0，交换次数是n*(n-1)/2， 最好情况有序度-元素交换次数是0, 平均下来是n*(n-1)/4。
          (8.2.2) 插入排序
          


    8.3 O(n)

    8.4 O(logn)















