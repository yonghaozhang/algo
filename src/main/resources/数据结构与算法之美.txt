1. 数据结构/算法的
    （a）复杂度分析（b）来历 (c)是什么（d）为什么 (e) 应用场景

=========================================================

2. 10种常用，基本的数据结构 + 10种算法。

==========================================================

3. 复杂度分析
    （1）为什么要复杂度分析？来历？
       （a) 事后统计法依赖环境和数据规模。不需要数据，就可以粗略估计算法执行效率的方法。

     (2) 大O时间复杂度特点
        (a) 代码执行时间随数据规模增长的变化趋势。
        (b) 加法法则：T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
        (c) 乘法法则: T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))

     (3) 空间复杂度特点
         (a)算法的存储空间随数据规模增长的变化趋势。

     (4) 复杂度比较：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)

     (5) 最好时间复杂度
       （a）在最理想情况下的时间复杂度。

     (6) 最坏时间复杂度
        (a) 在最糟糕情况下的时间复杂度。

     (7) 平均时间复杂度
        (a) 期望值

     (8) 均摊时间复杂度

======================================================

4. 数组
    (1) 是什么 ？什么是数组？
         (a) 线性表 -- 只有前后两个方向。
         (b) 连续的内存空间和相同的数据类型 -- 根据下表随机访问。时间复杂度 O(1)。
         (c) 插入 - 怎么插入？ 在k位置插入，k~n 向后移动 平均时间复杂度 O(n)。怎么提高性能 ？在k位插入，将k位移动到n+1位置，时间复杂度O(1)。
         (d) 删除 - 平均时间复杂度O(n) 怎么提高性能？标记删除算法 mark-sweep。

    (2) 为什么？数组 vs 容器
         （a）优点：存储基本类型， 没有autoboxing, unboxing, 性能first。
          (b)缺点: 但需要手动扩容。

    (3) 使用场景： 性能优先-写框架，底层开发（jdk）

=========================================================

5. 链表
    (1) 是什么？
          (a) 线性表
          (b) 零散内存块(节点) + 指针（下一个节点地址）

    (2) 单链表
        (2.1) 是什么?
          (a) 后驱指针
          (b1) 删除节点的值=某个值 - 时间复杂度: O(n):先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
          (b2) 删除给定指针指向的节点 - 时间复杂度：O(n): 已经知道要删除的节点，但是无法获取前驱节点
          (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
          (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
          (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(n): 先找到前驱节点 O(n), 然后在节点插入O(1)
          (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

    (3) 循环单链表？
        (3.1) 是什么？
          (a) 尾结点指向链表头部的单链表
          (b1) 删除节点的值=某个值 - 时间复杂度: O(n):先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
          (b2) 删除给定指针指向的节点 - 时间复杂度：O(n): 已经知道要删除的节点，但是无法获取前驱节点
          (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
          (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
          (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(n): 先找到前驱节点 O(n), 然后在节点插入O(1)
          (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

        (3.2) 为什么？  链尾到链头很方便
        (3.3) 使用场景？处理数据具有环形结构时

    (4) 双向链表？-- 实际开发中经常使用
        (4.1) 是什么？
           (a) 前驱指针 + 后驱指针
           (b1) 删除节点的值=某个值 - 时间复杂度: O(n)，先要找到要删除的位置(这部分O(n)),然后再删除（这部分O(1)）
           (b2) 删除给定指针指向的节点 - 时间复杂度：O(1), 已经知道要删除的节点，可以根据前驱指针获取前驱节点
           (c1) 在某个给定节点值前插入 - 时间复杂度： O(n): 先找到节点的前驱节点 O(n), 然后在节点后插入O(1)
           (c2) 在某个给定节点值后插入 - 时间复杂度： O(n): 先找到节点 O(n), 然后在节点后插入O(1)
           (c3) 在给定指针指向的节点前插入 - 时间复杂度： O(1): 先找到前驱节点 O(1), 然后在节点插入O(1)
           (c4) 在给定指针指向的节点后插入 - 时间复杂度：O(1): 找到节点指定节点O(1), 然后在节点后插入O(1)

        (4.2) 为什么？在给定指针指向的情况下比单链表插入，删除的性能高
        (4.3) 使用场景？LinkedHashMap 使用了双向链表， 空间换时间

    (5) LRU缓存淘汰算法
        (a) 一个有序的单链表，表尾是越早之前访问的。
        (b) 一个新数据来了，链表中有的话删除，在把新数据放到表头;
        (c) 链表中没有的话，如果缓存满了，删除表尾节点，将新数据放入表头;如果缓存没满的话，将新数据放到表头。
        (d) 时间复杂度 O(n)
        (e)怎么优化，达到时间复杂度O(1) --- 散列表记录每个数据的位置。

    (6) 理解指针
        将某个变量赋值给指针，就是将这个变量的地址赋值给指针。也就是说，指针中存储的是这个变量的内存地址。

    (7) 注意边界条件下代码是否能正常工作
        (a) 链表为空时
        (b) 链表只有一个节点，只包含2个节点
        (c) 头结点，尾节点

================================================================

6. 栈
   (1) 是什么？
        (a) 后进先出，先进后出。
        (b) 一种"操作受限"的线性表，只能在一端插入和删除。两种操作 push+pop。为什么要用这种受限的数据结构？特定的数据结构是对特定场景的抽象。
        (c) 支持动态扩容的顺序栈：学习摊还法分析时间复杂度。入栈 O(1), 出栈O(1)。

   (2) 为什么?
        (a) 为什么要用这种受限的数据结构？特定的数据结构是对特定场景的抽象。


   (3)使用场景
      当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特性。这时我们应该选择栈。
      (a) 栈在函数调用中（函数调用栈）

      (b) 表达式求值

      (c) 括号匹配

      (d) 浏览器前进后退功能

================================================================

7. 队列
    (1) 是什么?
        (a) 先进先出。
        (b) 一种"操作受限"的线性表. 两种操作：enqueue , dequeue。

    (2) 顺序队列
        (2.1) 是什么？
            (a) 基于数组结构，所以队列大小受限，如果不动态扩容的话。
            (b) 一个头指针，一个尾指针。 入队列时，尾指针后移动。出站头指针后移。
            (c) 如果队列已满（head=tail）就不插入;如果尾指针到尾部，但是头指针不在头部，将数据整体迁移。
            (d) 入队列，出队列时间复杂度O(n)。
        (2.2) 为什么？
            (a) 利用数组的有界性。
        (2.3) 使用场景
            (a) 响应时间敏感的系统，不让等待时间过长。 e.g. RPC

    (3) 链式队列
        (3.1) 是什么？
            (a) 基于链表结构，所以队列大小不受限。
            (b) 一个头指针指向头结点，一个尾指针指向尾节点。新入队列的元素发在尾部，从头部出队列。
            (c)入队列，出队时间复杂度都为O(1)。
        (3.2) 为什么？
            (a) 利用链表的无界性。
        (3.3) 使用场景
            (a) 响应时间不敏感的场景，比如离线job请求， 批量推送app push使用MQ 消峰。

    (4) 循环队列
        (4.1) 为什么用循环队列？
            (a) 用数组的时候，当tail==n, 会有数据搬移，影响性能。为了避免数据搬移。
        (4.2) 是什么？
            (a) 首尾相连，浪费一个位置没用。
            (b) 队满满条件： (tail + 1) % n = head。
            (c) 队列空条件：tail == head。
            (d) 入队列，出队时间复杂度都为O(n)。

     (5) 阻塞队列
        (5.1) 是什么？
            (a) 普通队列 + 阻塞功能
            (b) 满了不然插入，等待。
            (c) 空了不让取， 等待。
         (5.2) 为什么？
            (a)
         (5.3) 使用场景
            (a) 生产者-消费者模型

     (6) 并发队列
        (5.1) 为什么？
            (a) 如何在多线程操作同一个队列时，保证线程安全？
        (5.2) 是什么？
            (a) 简单方式： 在enqueue + dequeue 加上锁， 缺点：锁的颗粒度大，并发低。
            (b) 升级方式：CAS原子操作 -- 基于数组的循环队列。

     (7) 使用场景
        (7.1) 线程池中没有空闲线程，新的线程请求资源，线程池该怎么处理？
            (a) 非阻塞策略：拒绝请求
            (b) 阻塞策略：进入等待队列，等有空余线程后，取出请求继续处理。
            (c) 队列如何存储请求呢？
                (c1) 有界队列
                (c2) 无界队列
        (7.2) 资源有限场景下，当没有空闲资源的时候。


================================================================

8. 排序
    8.1
       (8.1.1) 如何分析一个排序算法？
          (a) 排序算法的执行效率
              (a1)最好，最坏，平均时间复杂度
              (a2)时间复杂度的系数，常数，低阶
              (a3)比较次数和交换（移动）次数
          (b) 是否原地排序 (空间复杂度 O(1))
          (c) 排序算法的稳定性 (稳定排序) : 待排序元素数组中，经过排序后，相同元素的顺序不变。

    8.2 O(n^2) --- 适合小规模数据。
          (8.2.1) 冒泡排序
            (1) 是什么？
                (a) 比较相邻元素，看是否满足大小关系，不满足则互换。
                    一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
                    一次冒泡，一个元素在他合适位置上，而且是靠近数组末尾的位置。
                (b) 原地排序，稳定排序。
                (d) 最好时间复杂度O(n), 最坏时间复杂度O(n^2),平均时间复杂度O(n^2)。
                (e) 最差情况有序度是0，交换次数是n*(n-1)/2， 最好情况有序度-元素交换次数是0, 平均下来是n*(n-1)/4。
          (8.2.2) 插入排序
            (1) 是什么？
                (a)思想：怎么在一个有序数组里插入一个数据？
                     拿待插入的数和已排序数组中的数比较，如果已排序组中的元素大于要插入的元素的值，就将这个元素向后挪动一位。
                     如果<=插入元素，这个元素+1的位置就是要插入的位置。
                (b)原地排序，可以做到稳定排序。
                (c)最好时间复杂度O(n), 最坏时间复杂度O(n^2), 在一个数组插入一个元素的时间复杂度是多少？O(n), 所以插入排序的平均时间复杂度O(n^2)

            (2)代码思想
                (a) 从第2个元素开始，让已排序组中的元素(j)依次和待插入元素(tmp)比较大小:
                        如果比tmp大，将这个j向后挪动一位;
                        如果比tmp小，j+1的位置就是要插入的位置。
          (8.2.3) 选择排序
            (1) 是什么？
                (a) 为什么叫选择排序？从未排序组择一个最小的元素i和未排序区第一个元素互换位置(已排序组最后一个元素位置)。
                (b) 最好时间复杂度O(n), 最坏时间复杂度O(n2), 平均时间复杂度O(n^2)
                (c) 原地排序，不是稳定排序。
            (2) 代码思想
                (a) 从未排序区第一个元素开始找到最小元素，和未排序区第一个元素互换位置(已排序组最后一个元素位置)。
          (8.2.4)为什么插入排序比冒泡排序更受欢迎？
                (a)冒泡排序代码实际到两个元素交换位置，就是3行赋值语句，但是插入排序是元素向后移动，只有一行代码，性能更好。
          (8.2.5) 适合小规模数据。

    8.3 O(nlogn)
        (8.3.1) 归并排序
            (1) 是什么？
                (1a)把数组从中间分成前后两个部分，对前后两个部分分别排序，再把排序好的两个部分合并起来。
                (1b) 算法思想 --- 先分治再分区
                (1c) 递归公式：sort(p...r) = merge(sort(p...q), sort(q+1...r))
                (1d) 终止条件：p >= r
                (1e) 稳定排序，不是原地排序。
            (2) 代码思想
                (2a) merge 函数怎么实现？如何将两个有序的数组，合并成一个有序的数组，要求时间复杂度O(n)?
                     两个指针分别指向两个数组第一个元素; 比较大小, 小的放入零时数组tmp;
                     然后小元素对应的数组指针向后挪动一位，重复比较步骤,直到其中一个数组元素全部放入tmp;
            (3) 使用场景
                (3a) 归并排序时间复杂度稳定在O(n)， 为什么没有得到广泛应用呢？ 不是原地排序，空间复杂度O(n)。


        (8.3.2) 快速排序
            (1) 是什么？
                (1a) 从要排序的数组中选择一个元素作为pivot(分区点)，将数组中小于pivot的数放到pivot左边，大于pivot的数放到右边。
                     再用分治的思想，对pivot 左边和右边分别重复(1a)的操作,直到区间元素个数=1。
                (1b) 算法思想 --- 先分区再分治
                (1c) 递归公式: sort(p...r) = sort(p...q) + sort(q+1...r)
                (1d) 终止条件： p>=r
                (12) 不稳定排序，原地排序。
            (2) 代码思想
                (2a) 关键是如何找到分区点位置(在一组无序元素中，在O(n)时间复杂度， O(n)的空间复杂度情况下，将数组根据一个给定值分成两组)?
                    (a) 选择数组中一个元素值作为分区值(pivotValue)，设置分区点位置初始位置pivotIndex=0
                    (b) 从数组第一个元素(j)开始和pivotValue比较，<pivotValue 则交换j和pivotIndex位置， pivotIndex++
                    (c) b步骤循环结束后，将pivotValue放置到pivotIndex位置元素的值 和 数组最后一个元素互换，分区完成，将pivotIndex返回。
            (3) 使用场景

                (3a) 如何在O(n) 情况下查找一个数组内第k小(大)元素？

        (8.3.3) 堆排序
            (1) 见10.2

        (8.3.4) 使用场景

    8.4 O(n)
        8.4.1 桶排序
          (1) 是什么？
            (1a) 把n个待排序数据分到m个桶里面，每个桶的排序时间(快排)复杂度O(n/mlogn/m),
                 如果桶的个数m接近于n, 每个桶时间复杂度就变为一个小常数, 总时间复杂度变为O(n)。
            (1b) 非原地，不稳定排序(使用快排)。
          (2) 代码思想
            (2a) 如何表示桶: int[][] = new int[bucketCount][bucketSize]
            (2b) 每个桶的元素大小的范围怎么定？ 找出待排序数组中最大和最小元素，用于确定桶里数据的范围。
            (2b) 将数据分配到桶中: bucketIndex标识哪个桶，bucketElementNum[i] 标识第i个桶内已经放几个元素。
            (2c) 对每个桶内排序使用快排。
            (2d) 将各个桶快排后的数据放回原数组。
          (3) 使用场景
            (3a) 数据范围不大，将数据划分到有限个桶里面， 桶与桶之间有着天然的大小关系。
            (3b) 比如根据年龄对100万用户排序。划分到120个桶(1岁到120岁).
            (3c) 比如按照订单金额对100万用户排序， 1~100元， 101-200元....分桶排序。
        8.4.2 计数排序
          (1) 是什么？
             (1a) 数据范围为k, 不大的情况，我们将数据划分为k个桶。每个桶内的数据都是相同的，省略掉了桶内排序。
             (1b) 稳定排序, 非原地排序。
          (2) 代码思想
             (2a) 查找待排序数组a[]中元素最大值，确定计数器范围
             (2b) 以数组元素以值为下标，放到计数器中c[]。
             (2c) 累加计数器
             (2d) 开始排序, 从原数组a中从后往前扫描数组，比如发现3时，c[3]的值表示有多少个元素<=3, 比如有4个的话， 3的位置就是r[4-1], 然后计数器c[3] -1。
             (2e) 将排序后的数组r[] copy到 a数组中。
          (3) 使用场景
             (3a) 给50万考生成绩排序。 做法：0 -900 分 901个桶。
             (3b) 数据范围不大，如果数据范围k比要排序的数据n大很多，就不合适了。
             (3c) 负数排序的话要转化成正数。

        8.4.3 基数排序
             (1) 是什么?
                (1a) 待比较的数据可以根据位(基数)来比较。
                (1b) 位之间有递进关系。
                (1c) 位比较要使用稳定排序(e.g. 计数排序)。
             (2) 代码思想
                (2a)
             (3) 使用场景
                (3a) 给10万个手机号(11位)排序。

        8.4.4 如何实现一个通用的高性能的排序算法
            (1) 线性排序算法对原始数据要求高，不适合通用排序函数的实现。
            (2) 对小规模数据排序，可以选择O(n^2)的算法。-- 选择排序
            (3) 对大规模排序可以选择O(nlogn) 的算法。 -- 快速速排序
            (4) 如何解决快排在极端情况下时间复杂度退化成O(n^2)的问题呢？-- 优化快速排序
                 (4a) 分区点的选择:被分开的两个分区中，数据的数量都差不多: 三数取中法。
            (5) 例子，C语言中的qsort()
                (5a) 当元素个数<4使用 使用插入排序。
                (5b) 默认用归并排序。
                (5c) 当数据量比较大的时候用快排。

================================================================

9. 查找
    9.1 二分查找
        (1) 是什么？
            (1a) 针对有序集合，和中间元素对比，将待查找区间缩小到一半，直到找到要查找的元素，或者区间被缩小为0。
            (1b) 时间复杂度 O(logn)
        (2) 代码思想
            (2a) 最简单的情况：有序数组中不存在重复元素
                (1) 用循环实现：
                    (*)  设置二分查找元素下标范围 low, high
                    (*) 循环退出条件: low >=high
                    (*) mid = (high - low) >> 2 + low, 防止溢出
                    (*) low = mid + 1 或者 high= mid - 1， 不是low=mid， high = mid
                (2) 用递归实现：
                    (*)递推公式 BS(p...r, x) = choose((BS(p...mid-1, x), BS(mid+1...r, x)) ; mid = (high - low) >> 1 + low
                    (*)终止条件 low >=high
            (2b) 查找第一个值等于给定值的元素
                (1) 当a[mid] = x时， 判断mid 前一个元素是否等于a[mid], 如果不等于，a[mid]就是我们要找的值；
                    如果等于a[mid],high = mid -1, 继续二分查找。
            (2c) ***最后一个值************
                (1) 当a[mid] = x时， 判断a[mid+1] 是否等于a[mid], 如果不等于，a[mid]就是我们要找的值；
                    如果等于a[mid],low = mid + 1, 继续二分查找。
            (2d) 查找第一个>=给定值的元素
                (1) 当 a[mid] >=x 时， 判断 a[mid-1] 是否>=x,如果 < x, 返回 mid;
                    如果 >=x, high = mid -1 继续二分查找。
            (2e) 查找最后一个<=给定值的元素
                (1) 当 a[mid] <=x 时， 判断 a[mid+1] 是否>x,如果 > x, 返回 mid;
                                        如果 <=x, low = mid + 1 继续二分查找。
        (3) 使用场景
            (3a) 依赖数组结构
            (3b) 数组是有序的
            (3c) 适合 "近似查找"问题
            (3d) 如何定位给定ip 地址对应的省份

    9.2 跳表
        (1) 跳表结构为了解决什么问题？
            * 降低普通链表在有序情况下查询某个值对应的元素的时间复杂度在O(n)
        (2) 什么是跳表？
            (2a) 链表+多级索引的结构。
            (2b) n个元素的链表，每k个元素建立一个索引， 会有多少层索引？ logk(n) -1, n >=k
            (2c) 如果每一层遍历m个节点， 那么时间复杂度为 m * k = m * (logk(n) - 1) = O(m* logn) = O(logn) ， 如果每3个节点(每隔1个节点)，m=3.
            (2d) 空间复杂度 O(n)
            (2e) 插入，删除 O(logn)
            (2f) 插入数据时，动态更新索引
                * 为什么要动态更新索引呢？ 随着插入数据增多，可能出现两个节点间的数据越来越多，导致跳表退化成单链表。
                * 如何决定插入的数据同时加入哪些索引层作为索引？ 通过随机函数生成k， 表示将这个节点添加到 1~k层作为索引。
        (3) 代码思想
            (3a) 按值查询一个节点x
                  * 构造一个Node[] forwards = Node[MAX_LEVEL] 表示一个节点在原始层+各个索引层的查询路径(每一层最小的那个大于插入元素的的元素)。
                  * 从最上层开始循环，找到节点值 > x 的节点后， 进入下一层索引。直到原始层forwards[0]。
            (3b) 插入一个节点
                  * 新节点索引层数。
                  * 构建要插入的节点，先找到update[i], 每个索引层最小的那个大于插入元素的元素，放到update[i]。
                  * update[].forward[] 成为新节点的forwards[]。update.forward[] 就是现在的新节点。
        (4) 使用场景
            (1) redis 有序集合（Sort Set) 用到了跳表， 按区间查找，只要定位区间起始点，再遍历查找。

    9.3 散列表(Hash Table)
        (1) 是什么
            (1a) 利用数组下标随机访问数据时时间复杂段为O(1)的特性。
            (1b) 通过散列函数(hash函数)，把元素的键值映射成数组下标(散列值/哈希值)，然后存储在数组中。
                 当我们要查询元素时，按照元素的键值通过散列函数转换成数组下标，然后找到元素的值，
        (2) 散列函数
            (2a) 如果 key1 = key2, 那么hash(key1) = hash(key2)
            (2b) 如果 key1 /= key2, 那么hash(key1) /= hash(key2)
            上面(2b) 几乎不可能实现，所以有散列冲突。
            (2c) 如何设计散列函数?
                * 不要复杂，复杂了必然会消耗计算时间，影响到散列表的性能。
                * 取手机号后四位 作为散列值
                * 每个单词每个字母的ascii 值进位相加，和散列表大小取余，作为散列值。
            (2d) 散列函数是hash函数的一个应用。
        (3) 散列冲突
            (3a) 开放寻址法
                (1) 是什么？如果出现了冲突，就重新探测一个空闲位置，将其插入。
                (2) * 线性探测法: 向散列表插入数据时，如果位置已经被占用，就从开始，依次往后查，直到发现空闲位置。
                    * 二次探测法: 和线性探测原理一样，但是步长为 2^n。
                (3) 装载因子(load factor): 填入表中的元素个数/散列表的长度。装载因子过大怎么办？动态扩容
                    * 重新申请一个更大的散列表，通过新的散列函数将原有的值迁移到新的散列表中。
                    * 如何避免抵消扩容? 首先，当触达到转载因子时，只申请空间，不做全量迁移数据; 然后每次插入新数据时，迁移一个老数据到新的散列表中。
                (4) ThreadLocalMap
                (5) 优点: 存储在数组中，有效利用CPU缓存加速查询。
                (6) 缺点： 因为都存储在一个数组中，冲突代价高，使用数组，更加浪费空间。
                (7) 当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因.

            (3b) 链表法
                (1) 散列表中每个桶(bucket)/槽(slot) 会对应一条链，所有散列值相同的元素放到相同槽的链表中。
                (2) 插入时间复杂度 O(1), 查找/删除 O(k), k是链表的长度， 对于散列均匀的散列函数，k = n/m。 n是散列中数据个数,m是槽数。
                (3) LinkedHashMap
                (4) 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，
                    比如用跳表，代替链表。

        (4) 工业级散列表 HashMap
            (4a) 初始大小 - 可配置的初始大小。
            (4b) 装载因子(0.75) + 动态扩容(*2)
            (4c) 散列冲突解决方式 - 列表法，当链表长度>8 变换成红黑树。
            (4d) 散列函数 - (h ^ (h >>> 16)) & (capitity -1)  ， 位移异或算法 + 除留余数法(A%B = A & (B-1))

        (5) 使用场景
            (5a) Word文档中单词拼写检查功能。
            (5b) 10万条url访问数据，根据访问次数排序。
            (5c) 有两个字符串数组，每组大约10万条，如何快速找出数组中相同的字符串。
            (5d) LRU 缓存淘汰算法
                * 为什么有散列表？原始基于链表的LRU算法时间时间复杂度为O(n), 现在通过散列表+链表将时间复杂度降到O(1).
                * 实现思想：
                    * 原来的单链表 变为 双向链表(前驱指针，后驱指针)
                    * 使用一个散列表，散列表使用链表法，链表每个元素就是单链表中的元素，通过一个hnext 指针串联链表法。
                    * 查找数据：通过散列表查找一个元素，再将元素放在双向链表尾部 O(1)。
                    * 删除数据：通过散列表查找一个元素，在用过前驱指针在O(1) 删除这个元素。
                    * 添加数据：通过散列表查找一个元素，如果元素在双向链表中，将这个元素移动到链表尾部;
                              如果元素不存在，看缓存是否已满;
                                 已满,删掉双向链表头部元素,将要插入的元素放到尾部，
                                 未满,将元素放到链表尾部。
            (5e) Redis 有序集合 (每个成员对象都有key score)
                * score 使用 跳表结构, 但是这样按照key 查找效率会很低，
                 所以按照key 构建一个散列表，这样对按照key 的增，删，查可以做到O(1)。
            (5f) LinkedHashMap
                * 是通过链表法解决散列冲突么？不是,指的是双向链表
                * 散列表 + 双向链表
                * LinkedHashMap 本身就是一个支持LRU缓存淘汰策略的缓存系统。
            (5g) 为什么散列表要和链表经常一起使用呢？
                * 散列表虽然支持O(1) 的插入，删除，查找，但是无法支持按照顺序快速遍历数据，所以我们将散列表和链表(或者跳表)结合起来一起使用。

        (6) hash算法
            (6a) 什么是hash算法？
                * 任意长度的二进制值串 --> 固定长度的二进制串。
                * 单向性。
                * 输入数据敏感，只修改一个bit, 输出结果也会大不相同。
                * 冲突的概率小。
                * 算法执行效率尽量高。
            (6b) 应用场景
                * 安全加密
                    * 单向性， 冲突小。字典攻击 -- 加盐解决。
                * 唯一标识
                    * 对大数据做信息摘要，从图片开头取100个字节，中间取100字节，结尾曲100个字节，MD5哈希，作为图片的摘要。
                * 数据校验
                    * 如何校验文件块的安全，正确，完整？ -- 利用hash算法对数据的很敏感。
                * 散列函数
                    * 单向性，冲突小。
                * 负载均衡
                    * 如何实现一个客户端的请求都路由到同一个服务器上?
                      客户端IP地址计算hash值，然后将服务器列表的大小进行取模运算。
                * 数据分片
                    * 统计"搜索关键词"出现的次数，搜索日志很大，单台机器处理慢。
                        * 先对数据hash后分片，然后采用多态机器分片处理 - MapReduce  - 分之思想。
                * 分布式存储
                    * 如何解决分布式存储扩容造成的雪崩问题呢？ 即在新加入一个机器扩容时，不需要大量数据迁移。
                        * 一致性hash: k个机器，hash 值总范围 0 ~ Max, 将整个范围划分为m 个区间,每个区间有 (Max/m)-slot(槽),
                          每个机器负责 m/k个槽。
                        * 如果扩容了一个机器，将部分槽迁移到新机器上，避免了重复hash数据和全部数据迁移。

==============================================================

10. 树
    10.1 二叉树
        10.1.1 完全二叉树
            (1)什么是完全二叉树?
                * 除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。

        10.1.2 满二叉树
            (1) 什么是满二叉树？
                * 所有叶子节点都在最底层。
                * 每个节点都有左右两个子节点。

        10.1.3 数的存储
            (1) 二叉链式存储
            (2) 数组顺序存储
                * 根节点存储在下标 i = 1 的位置，
                * 那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置
                * 反过来，下标为 i/2 的位置存储就是当前节点的父节点

        10.1.4 二叉树的遍历
            (1) 前序遍历 节点 -》左子树 -》右子树
                preOrder(node) = print(node) -> print(node->left) -> print(node-right)
            (2) 中序遍历 左子树 -》节点 -》右子树
                 inOrder(node) = print(node->left) -> print(node) -> print(node-right)
            (3) 后续遍历 左子树 -》右子树 -》节点
                   postOrder(node) = print(node-left) -> print(node->right) -> print(node)
            (4) 二叉树遍历的时间复杂度是O(n)

        10.1.4 二叉查找树/二叉搜索树/二叉排序树 (Binary Search Tree)
            (1) 任意一个节点，左子树的值都有<这个节点;右子树的值>这个节点。 (左小右大)
            (2) 代码思想
                (2a) 查找一个元素
                    * 比较这个元素和节点大小， =节点值，返回;小于节点值，在左子树中查找;大于节点值，在右子树中查找。
                (2b) 插入一个元素
                    * 要插入的元素一般都在叶子节点上，判断要插入的元素值，如果小于节点值，在左子树中查找;
                      如果大于节点值，在右子树中查找，直到子节点=null(叶子节点)。
                (2c) 删除一个元素
                    * 如果要删除的节点没有子节点，就将要删除节点的父节点指向子节点的指针=null;
                    * 如果要删除的节点有一个子节点，就将要删除节点的父节点指向这个子节点。
                    * 如果要删除的节点有左右两个子节点, 找到这个节点右子树中最小的节点，替换掉这个要删除的节点，再删除掉这个最小节点。
            (3) 中序遍历 O(n)
                    * 输出有序数组
            (4) 重复数据的二叉树
                (4a) 一种使用链表，或者动态扩容的数组。
                (4b) 一种是将相等的节点放在右树，当做大于这个节点来处理。
            (5) 查找，插入，删除的最好时间复杂度在O(logn), 最糟糕在O(n).

        10.1.5 二叉查找/搜索/排序树(BinarySearchTree)
            (1) 什么是二叉查找树？
                * 在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值
                * 右子树节点的值都大于这个节点的值
            (2) 在二叉查找树中查找一个节点
                * 我们先取根节点，如果它等于我们要查找的数据，那就返回
                * 如果要查找的数据比根节点的值小，那就在左子树中递归查找
                * 如果要查找的数据比根节点的值大，那就在右子树中递归查找
            (3) 二叉查找树的插入操作
                * 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；
                * 如果右边不为空，就再递归遍历右子树，查找插入位置
                * 如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置
                * 如果不为空，就再递归遍历左子树，查找插入位置。
            (4) 二叉查找树的删除操作
                * 第一种情况是，如果要删除的节点没有子节点:
                    我们只需要直接将父节点中，指向要删除节点的指针置为 null.
                * 如果要删除的节点只有一个子节点（只有左子节点或者右子节点）:
                    我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了.
                * 如果要删除的节点有两个子节点:
                    我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，
                * 还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。
            (5) 快速地查找最大节点和最小节点、前驱节点和后继节点
            (6) 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效
            (7) 支持重复数据的二叉查找树
                * 第一种方法:二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
                * 第二种方法： 我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。
            (8) 插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。
        10.1.5 平衡二叉查找树
            10.1.5.1 平衡二叉树
                (1a)
                    * 为什么？ 解决普通二叉查找树在频繁插入，删除情况下，出现时间复杂度退化的问题。
                    * 是什么？
                        * 任意一个节点的左右子树的高度相差不能大于1。满二叉树，完全二叉树都是平衡二叉树。
                        * 重点在于平衡-整个树左右看起来比较对称，性能不退化的太严重
                        * 一个合格的平衡二叉树(近似平衡)：只要树的高度不比logn大很多，我们任然可以认为是一个合格的平衡二叉树
            10.1.5.2 平衡二叉查找树
                (1a) 平衡二叉树 AND 二叉查找树
                (1b) 有了散列表，为啥还要用二叉查找树？
                     (*) 散列表是无序的，但是中序遍历二叉查找树，得到的是有序的。
                     (*) 散列表在散列冲突的情况下，性能不稳定。但是平衡二叉树的性能比较稳定在O(logn).

            10.1.5.3 红黑树/R-B Tree
                (1a) 不是严格的平衡二叉查找树，是一种合格的平衡二叉查找树。
                (1b) 是什么 --   10.1.5.1 (1a)
                (1c) 树的高度2logn

    10.2 堆
        10.2.1 是什么？ 完全二叉树 + 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。
        10.2.2 如何实现一个堆？
            (1) 存储堆：数组
            (2) 往堆中插入一个元素 - 自下往上堆化
                (*) 堆化 -- 顺着节点所在的路径，向上后者向下对比，然后交换。
            (3) 删除堆顶元素
                (*) 把最后一个元素放到对顶，然后自上往下堆化。
        10.2.3 如何基于堆排序
            (1) 建堆
                (*) 方法1：从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化
                (*) 方法2：从后往前处理数组，并且每个数据都是从上往下堆化
            (2) 排序
                (*) 将对顶元素和最后一个元素(下标n)交换位置, 再对n-1个元素重新建堆
        10.2.4 使用场景
            (1) 优先级队列
                * 合并有序小文件
                * 高性能定时器： 通过优先级队列，获取队首任务的时间点,与当前时间点相减，等到T, T秒后定时器再来执行任务。
            (2) 利用堆求 Top K
                * 静态数据集合求Top K：维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。 时间复杂度O(nlogK)。
                * 动态数据求Top K， 实时Top K
                    ** 包含两个操作：(a) 添加数据并且重新堆化K (b) 询问当前的top K 数据。
            (3) 求中位数
                (a) 维护一个大顶堆，一个小顶堆，如果一共n个元素求中位数，大顶堆要有 2/n + 1个元素, 小顶堆有 2/n个元素，大顶堆的堆顶是中位数。
                (b) 新插入一个数，和大顶堆堆顶比较，>大顶堆堆顶，放到小顶对。反之，放到大顶堆。（在堆中插入一个元素）
                (c) 将其中一个堆堆顶的元素不停的移动到另外一个堆，满足约束(1)
            (4) 如何快速求接口的 99% 响应时间? O(logn)
                (a) 99% 百分位数大约就是第 n*99% 个数据，同类，80% 百分位数大约就是第 n*80% 个数据, 大顶堆堆顶的数据就是我们要找的 99% 响应时间
                (b) 每次插入元素，都要保持大顶堆中的数据占 99%，小顶堆中的数据占 1%。不满足的话通过移动一个堆堆顶元素到另外一个堆。
            (5) 如何快速获取到Top 10最热门的搜索关键词？

==============================================================

11. 图
    1. 概念
        (1) 顶点，边，顶点的度（入度/出度）
        (2) 有向图/无向图
        (3) 带权图
    2. 怎么存储图这种数据结构?
        (1)邻接矩阵
            (a) 简单直观，但浪费存储空间
        (2)邻接图
    3. 搜索算法
        3.1 BFS
            (1) 代码实现
                (*) boolean visited[], Queue queue, prev[]

        3.2 DFS
            (1) 代码实现
                (*) boolean visited[], prev[], found

==============================================================

12. 字符串匹配
    1. 概念
        1.1 主串，模式串，子串
            * 字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串，字符串A中每次和B比较的字符串就叫做子串。

    2. 单模式串匹配算法 (在一个主串中查找一个模式串)
        2.1 BF算法 （Brute Force/暴力匹配算法/朴素匹配算法）
            (1) 算法思想：我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。
            (2) 时间复杂度： 最坏情况下 O(n*m)
            (3) 为什么它的时间复杂度高，但是是确实实际开发中一个比较常用字符串匹配的算法？
                (*) 实际开发中，模式串和主串都不会太长。
                (*) 当主串和模式串比较出现不匹配字符的时候就可以停止，不需要把m个字符串都匹配下。
                (*)代码简单，不容易出错，KISS。

        2.2 RK算法 (Rabin-Karp算法)
            (1) 算法出发点
                (a) BF算法 每次检查主串与子串是否匹配，需要依次比对每个字符，所以时间复杂度比较高，有办法优化么?
            (2) 算法思想
                (a) 计算子串hash值：用一个K进制数来表示子串,这个K进制数转换成十进制数，作为子串的hash值。时间复杂度O(n)
                (b) 模式串hash值和子串hash值之间比较, 总共 (n-m+1)次， 所以时间复杂度O(n)

        2.3 BM算法(Boyer-Moore)
            (1) 算法思想：当模式串和主串不匹配时，有什么办法可以让将模式串往后多滑动几位呢？
            (2) 算法原理
                (a) 坏字符规则（bad character rule）
                    * 什么是坏字符？
                        从模式串末尾往前倒着和主串匹配，我们发现某个主串中的字符没法和模式串匹配的时候，我们把这个字符叫做坏字符。
                    * 发现坏字符后，模式串应该向前移动几位呢？
                        Si:坏字符对应的模式串中的字符的下标，
                        Xi:坏字符在模式串中下标;如果不存在，Xi记为-1，
                        那么模式串向前移动Si-Xi位。
                        如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。
                    * 利用坏字符规则，BM算法在最好情况下可以达到O(n/m)
                (b) 好后缀规则(good suffix shift)
                    * 为什么要用好后缀规则？
                        主串是 aaaaaaaaaaaaaaaa，模式串是 baaa， si = 0, xi=3, si-xi=-3,模式串可能会倒退。
                    * 什么是好后缀？
                        主串和模式串匹配的后缀串。好后缀指的是主串中的部分。
                    * 怎么使用好后缀规则？
                        在模式串中，查找跟好后缀匹配的另一个子串；
                        在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；
                (c) 当模式串和主串中的某个字符不匹配的时候，如何选择用"好后缀规则"还是"坏字符规则"，来计算模式串往后滑动的位数？
                    * 分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。

        2.4 KMP算法
            (1) 算法基本原理




    3 多模式串匹配算法  (一个串中同时查找多个串)
        3.1 它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率.

        3.2 字典数(Trie树)
            (1) 什么是Trie树？
                (a) 专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题.
                (b) Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起.
            (2) 如何实现一个Trie树?
                (a) 两个基本操作
                    * 将字符串集合构造成 Trie 树
                    * 在 Trie 树中查询一个字符串
                (b) 如何存储一个Tire树
                    * 我们在数组中下标为 0 的位置，存储指向子节点 a 的指针，
                      下标为 1 的位置存储指向子节点 b 的指针，
                      以此类推，下标为 25 的位置，存储的是指向的子节点 z 的指针.
                      如果某个字符的子节点不存在，我们就在对应的下标的位置存储 null.
            (3) 查找某个字符串的时间复杂度是多少？
                * 构建Trie树的时间复杂度是O(n), n是所有字符串的长度和.
                * 构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度.
            (4) Trie 树真的很耗内存吗？
            (5) Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。
                Trie 树比较适合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。
            (6) 使用场景
                (a) 搜索引擎的搜索关键词提示功能
                (b) 输入法自动补全功能, IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能

        3.3 AC自动机 (能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？)

==============================================================

13. 算法思想
    13.1 贪心算法(greedy algorithm)
        13.1.1 如何理解“贪心算法”？
            (1) 我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。
            (2) 用贪心算法解决问题的思路，并不总能给出最优解. 主要是前面的选择，会影响后面的选择。
        13.1.2 实战分析
            (1) 分糖果
            (2) 钱币找零
            (3) 区间覆盖
            (4) 如何用贪心算法实现霍夫曼编码？
                (a) 先考察文本中有多少个不同字符
                (b) 再考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。
                (c) 但是如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？
                        * 贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。

    13.2







